name: Azure Continuous Delivery

# Activación manual del workflow desde GitHub Actions
on:
  workflow_dispatch:
    inputs:
      IMAGE_REPOSITORY:
        description: 'Repository of the image (debe coincidir con el App Service)'
        required: true
        default: 'smartschedulingjava'
      IMAGE_TAG:
        description: 'Tag de la imagen (ej. latest, v1.0.0)'
        required: true
        default: 'latest'
      AZURE_WEBAPP_NAME:
        description: 'Nombre del App Service en Azure'
        required: true
      PORT:
        description: 'Puerto de la aplicación en Azure'
        required: true
        default: '8080'

# URL completa de la imagen en Azure Container Registry
env:
  IMAGE_URL: ${{ secrets.ACR_NAME }}.azurecr.io/${{ github.event.inputs.IMAGE_REPOSITORY }}:${{ github.event.inputs.IMAGE_TAG }}

jobs:
  # 1. Build y push de la imagen a Azure Container Registry
  build-and-push-image:
    name: 'Build and Push to ACR'
    runs-on: ubuntu-latest

    steps:
      - name: Checkout del repositorio
        uses: actions/checkout@v4

      - name: Login en Azure Container Registry
        uses: azure/docker-login@v1
        with:
          login-server: ${{ secrets.ACR_NAME }}.azurecr.io
          username: ${{ secrets.ACR_NAME }}
          password: ${{ secrets.ACR_PASSWORD }}

      - name: Build y push de la imagen
        uses: docker/build-push-action@v6
        with:
          push: true
          tags: ${{ env.IMAGE_URL }}
          file: Dockerfile

  # 2. Despliegue de la imagen en Azure Web App for Containers
  deploy:
    name: 'Deploy remote container to Azure'
    runs-on: ubuntu-latest
    needs: build-and-push-image

    steps:
      - name: Despliegue en Azure Web App
        uses: azure/webapps-deploy@v2
        with:
          app-name: ${{ github.event.inputs.AZURE_WEBAPP_NAME }}
          publish-profile: ${{ secrets.AZURE_WEBAPP_PUBLISH_PROFILE_JUANDULCEY }}
          images: ${{ env.IMAGE_URL }}

  # 3. Pruebas locales antes del despliegue (doble garantía)
  test-api-local:
    name: 'Run API tests locally with Docker'
    runs-on: ubuntu-latest
    needs: build-and-push-image

    steps:
      - name: Checkout de pruebas Hurl
        uses: actions/checkout@v4
        with:
          sparse-checkout: |
            tests/resources/resource.hurl
          sparse-checkout-cone-mode: false

      # -----------------------------
      # Crear archivo .env desde secretos
      # -----------------------------
      - name: Create .env file
        run: |
          echo "DB_URL=${{ secrets.DB_URL }}" >> .env
          echo "DB_USER=${{ secrets.DB_USER }}" >> .env
          echo "DB_PASSWORD=${{ secrets.DB_PASSWORD }}" >> .env
          echo "SERVER_PORT=8080" >> .env
          echo "JWT_SECRET=${{ secrets.JWT_SECRET }}" >> .env
          echo "JWT_EXPIRATION=86400000" >> .env

      # -----------------------------
      # Login en Azure Container Registry
      # -----------------------------
      - name: Docker login to ACR
        run: echo "${{ secrets.ACR_PASSWORD }}" | docker login ${{ secrets.ACR_NAME }}.azurecr.io -u ${{ secrets.ACR_NAME }} --password-stdin

      # -----------------------------
      # Descargar imagen desde ACR
      # -----------------------------
      - name: Pull image from ACR
        run: docker pull ${{ env.IMAGE_URL }}

      # -----------------------------
      # Levantar contenedor local para pruebas
      # -----------------------------
      - name: Run container from ACR image
        run: |
          echo "Iniciando contenedor Smart Scheduling..."
          docker run -d \
            --name smart-scheduling-test \
            --env-file .env \
            -p 8080:8080 \
            ${{ env.IMAGE_URL }}

          echo "Esperando a que la API esté lista..."
          for i in {1..30}; do
            if curl -s http://localhost:8080/actuator/health >/dev/null; then
              echo "✅ API lista para pruebas"
              break
            fi
            sleep 2
          done

      - name: Instalar Hurl (herramienta de pruebas de API)
        uses: gacts/install-hurl@v1

      - name: Ejecutar pruebas Hurl contra localhost
        run: |
          echo "Ejecutando pruebas de Resource..."
          hurl tests/resources/resource.hurl --test --error-format long --variable host=http://localhost:8080

          echo "Limpiando entorno de pruebas..."
          docker logs smart-scheduling-test > target/test-logs.txt || true
          docker stop smart-scheduling-test || true
          docker rm smart-scheduling-test || true

  # 4. Pruebas post-despliegue contra Azure WebApp
  test-api-deployed:
    name: 'Run API tests against deployed Azure service'
    runs-on: ubuntu-latest
    needs: [build-and-push-image, deploy]

    steps:
      - name: Checkout de pruebas Hurl
        uses: actions/checkout@v4
        with:
          sparse-checkout: |
            tests/resources/resource.hurl
          sparse-checkout-cone-mode: false

      - name: Instalar Hurl
        uses: gacts/install-hurl@v1

      - name: Ejecutar pruebas contra Azure WebApp
        run: |
          echo "Probando API desplegada en Azure..."
          hurl tests/resources/resource.hurl \
            --variable host=https://${{ github.event.inputs.AZURE_WEBAPP_NAME }}.azurewebsites.net \
            --connect-timeout 20s \
            --error-format long \
            --verbose \
            --test
